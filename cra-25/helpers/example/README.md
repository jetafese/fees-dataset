## CRA-25

This folder introduces the notion of private variables via an example. As we
develop the framework for comparing consistency of business logic to code,
these `edge` cases that implement temporary/bespoke properties need to be
handled. The reason why this is important is that the business wants to ensure
the integrity of their framework, modulo, discounts/promotions. We use the CRA
example to articulate this point.

The government of canada has specified the taxes for the 2025 year at the following site: https://www.canada.ca/en/revenue-agency/services/tax/individuals/frequently-asked-questions-individuals/canadian-income-tax-rates-individuals-current-previous-years.html

We are going to translate the files (e.g., cra-25/federal/federal.txt) to SMT
and also request an LLM generate programs in BL (see grammar in language/BL.g4).
These programs can take private variables such as SIN into account to simulate
reality. For example, temporary foreign workers have SINs that start with 9 
(e.g. 900999999) where they would be exempt from paying taxes under certain
schemes.

## Structure
```
├── ab.smt2         (generated using Automaded Reasoning Checks (ab.txt, cra-25/helpers/model.json))
├── ab.txt          (input file: tax brackets for Alberta)
├── bounds.json     (generated by user/LLM)
├── prog.bl         (generated using prompt in cra-25/helpers/nl_to_bl.md)
├── prog.smt2       (generated using parser in language/main.py)
└── README.md       (this file)
```

## Workflow
1. Generate `prog.bl` using your LLM of choice and the give prompt
2. Use our workflow to generate the SMT file `prog.smt2`
3. Generate `ab.smt2` using Automated Reasoning Checks on AWS
4. Write/Generate the `bounds.json` file. You can use the given file for reference
5. Run our checker: `language/checkers/graphs/checker.py ab.smt2 prog.smt2 bound.json`

## Framework

The classic equivalence problem is: given f1(a), f2(b, c), prove that f1 and
f2 are have the same output for all inputs. A modification of this problem is:
given f1(a), f2(b, c), prove that f1 and f2 are have the same output for all
inputs where only a == b

This is an opportunity to reframe the problem so that we can find all possible
assumptions/cases that need to hold in order for the equivalent to hold.
For example, in this folder, we want to establish that in every case where the
special restriction is not triggered, the two functions for the tax code are
equivalent.

In other words, the queries:
1. f1(a) = f2(b, c) is valid, if an only if, Not(special)
2. special => f1(a) = f2(b, c) is never the case